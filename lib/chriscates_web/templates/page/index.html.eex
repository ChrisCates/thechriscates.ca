<div class="content">
  <p>
    I've decided to dedicate a section of my site to "The 13 Books of Euclid" <a href="/euclid">here</a>.
    I will also in the future have sections dedicated to Archimedes "The Method" and will also have
    several other sections dedicated to various branches of Advanced Transcendentals in Pure Mathematics
    such as Calculus. Everything will be presented in code form and in Javascript for legibility.
    If you would like C or another language based implementation for demos. Please email me (my email is in the header)
    and I'll consider your case for another language (but I'd probably only seriously consider C, Java or Python).
  </p>

  <p>
    I'm also writing an ebook called <a href="/number_theory">Number Theory in Javascript</a> you can learn more
    by clicking that link.
  </p>

  <h2>Recent ramblings and thoughts</h2>

  <a href="/emoji_contract" class="link">
    <h3>EmojiCoin Smart Contract</h3>
    <h3>October 6th, 2017</h3>
    <p>
      I thought there were several interesting things I implemented in my EmojiCoin
      smart contract. Such as nested mapping for each respective emoji as well as
      using constant logic to effiecently return balance information from the blockchain.
    </p>
  </a>

  <a href="/division_algorithm" class="link">
    <h3>Thoughts about Division</h3>
    <h3>October 3rd, 2017</h3>
    <p>
      My friend Kurt one time said that all math is just clever addition. In reality he is very right.
      We can even prove that Division itself can be reduced to a simple subtractive problem (which is
      addition with negative numbers when you think about it).
    </p>
  </a>

  <a href="/intelligent_graphs" class="link">
    <h3>Intelligent Graphs in Rust (Part 1)</h3>
    <h3>October 1st, 2017</h3>
    <p>
      I wrote a simple yet intelligent graph implementation in Rust that automatically detected and connected
      nodes based on edges. While the current implementation is seemingly simple. I want to upgrade it eventually
      to explain what sort of graphs it adheres to. Also the potential of having weighted graph vectors is
      also a possibility.
    </p>
  </a>

  <a href="/binary_search_tree" class="link">
    <h3>Help me improve this Binary Search Tree</h3>
    <h3>September 30th, 2017</h3>
    <p>
      Writing a Binary Search Tree is significantly easier in Javascript than it is Rust.
      I did however, find myself extremely entertained figuring out the solution after tussling
      with the compiler for a couple hours. Please email me if you know a better implementation
      in a more idiomatic Rust way to implement a binary search tree.
    </p>
  </a>

  <a href="/sort_binary_array" class="link">
    <h3>Sorting a Binary Array with O(n) Complexity</h3>
    <h3>September 29th, 2017</h3>
    <p>
      I found the solution rather menial. But nevertheless, I still felt inspired
      to blog about it, since typically sorting algorithm are O(n^2) or O(n log n)
      which neither are ideal. The key here is that we are sorting binary values
      so it's safe to assume the resultant values in a discretized fashion.
    </p>
  </a>

  <a href="/rust_merge_sort" class="link">
    <h3>Notes about Merge Sort in Rust</h3>
    <h3>September 29th, 2017</h3>
    <p>
      While overall I find programming Rust extremely fun and rewarding. I wanted to write several
      notes about caveats (or paradigm shifts rather) when programming Rust in comparison to
      an interpreted language or tried language like C/++.
    </p>
  </a>

  <a href="/rust_ledger" class="link">
    <h3>Building a blockchain ledger in Rust</h3>
    <h3>September 26th, 2017</h3>
    <p>
      While what I've built so far more reflects the emojichain blog post.
      I have to say, writing even just this much code and seeing it work effectively has been extremely
      rewarding in Rust. This blockchain database is a bit more serious then my previous project and
      has a core intention of being a distributed, scalable ledger with fault tolerance. A lot of work
      for one person I know, but who knows maybe it'll catch on?
    </p>
  </a>

  <a href="/back_to_rust" class="link">
    <h3>Back to Rust: Initial Thoughts</h3>
    <h3>September 26th, 2017</h3>
    <p>
      I was writing a database in C. Then I quickly glanced over the perks of C++, and then Rust
      and clearly thought Rust was a winner. After all the nature of the language makes system
      level design extremely hard to fuck up. However, funny enough, even writing to disk
      "Hello World" took more then 5 minutes. Which C++ took me 30 seconds to figure out.
    </p>
  </a>

  <a href="/cyclotomic_polynomials" class="link">
    <h3>Cyclotomic Polynomials and Phi Functions</h3>
    <h3>September 21st, 2017</h3>
    <p>
      You'd think I'd be drawing circles in code because who doesn't love circles and pi?
      In reality though, I'm just writing Phi Functions today.
      It's some cool shit that's one thing for sure. But what exactly
      is a Phi function?
    </p>
  </a>

  <a href="/rust_vs_c" class="link">
    <h3>Rust versus C/++</h3>
    <h3>September 21st, 2017</h3>
    <p>
      Normally I have code samples. Tonight I just feel like rambling about code. In particular I want to
      make a case for Functional versus Imperative Systems level programming and how Functional programming is
      better for the developer economy because we can't trust developers to write good code.
    </p>
  </a>

  <a href="/fft" class="link">
    <h3>Sine, Cosine, Tangents and Fast Fourier Transforms</h3>
    <h3>September 19th, 2017</h3>
    <p>
      Normally we don't really think much about Sine, Cosine or Tangent functions... Maybe you did a bit in Calculus,
      but most people don't really touch upon anything else then early transcendentals in Calculus. I believe
      Fourier Transforms are classified as an "Advanced Transcendental" method in Calculus. But are still
      relatively simple concept to grasp... I know I keep saying otherwise complex shit is "simple", but,
      hey maybe I'm right and this is actually simple? ðŸ¤”
    </p>
  </a>

  <a href="/poker_and_ether" class="link">
    <h3>How to use Ethereum for gambling</h3>
    <h3>September 19th, 2017</h3>
    <p>
      I think one of the main benefits and use cases for Ethereum over Bitcoin is how accessible
      Ethereum makes writing smart contracts and "dApps" with it. Ethereum has it's own compiled
      language called "Solidity" which lends a lot of it's syntax and structure to Golang. I
      would almost argue Solidity being a successor to the Golang language. Much like how Kotlin
      was the Google's brainchild and prototype successor to Golang.
    </p>
  </a>

  <a href="/merkle_trees" class="link">
    <h3>Merkle Trees, unfortunately are not trees</h3>
    <h3>September 14th, 2017</h3>
    <p>
      There are so many damn cool trees out there... Willow, Oak, Pine... Unfortunately,
      Merkle Trees are an algorithm, not a tree. The concept of
      Merkle Trees is fairly straightforward. Child nodes hash
      their parent nodes. So basically it's a graph with hashes
      hashing each other (with some sort of original value).
    </p>
  </a>

  <a href="/dags" class="link">
    <h3>What the heck are DAGs?</h3>
    <h3>August 20th, 2017</h3>
    <p>
      You've probably heard of DAGs (Directed Acyclic Graphs) because of Ethereum.
      If you're familar with Graph Theory, have used Graph DBs or Binary Trees.
      Grasping the concept of DAGs shouldn't be a problem. Basically think of it this way,
      every vertex is references it's previous and next value. Thus each edge will always be
      unique in the graph.
    </p>
  </a>

  <a href="/linked_lists" class="link">
    <h3>Linked Lists and Blockchain</h3>
    <h3>August 20th, 2017</h3>
    <p>
      Honestly, me and my friend Chris Hahn always ponder this... What is so special about Blockchain? It's literally just an
      obfuscated way of saying you made a Linked List. Sure Cryptocurrencies throw in some SHA-2, but... really. It literally
      is just a linked list. I don't get the hype around it. Linked Lists have existed for decades, while Linked Lists are
      a very effiecent way of storing datasets. It just seems kind of funny to me that only NOW does it catch on.
    </p>
  </a>

  <a href="/ring_buffers" class="link">
    <h3>Non-Atomic Ring Buffers in Node.js</h3>
    <h3>August 20th, 2017</h3>
    <p>
      What? Were you honestly expecting a lock-free atomic ring buffer to be built in pure node.js?
      Yea keep dreaming. Anyway, recently came across the need for a Ring Buffer in JS. Of course,
      I would LOVE to be able to leverage it in atomic form. We're kind of stuck with what V8 gives us so...
    </p>
  </a>

  <a href="/emojichain" class="link">
    <h3>Emoji Blockchain Tech in 50 lines of code</h3>
    <h3>August 13th, 2017</h3>
    <p>
      Imagine a world where your blockchains are encrypted with Emojis... Well, I created the
      base technology for such a thing and you can learn more about it here. The codebase for a
      functional (peerless) blockchain is only 50 lines of code in Node.js!
    </p>
  </a>

  <a href="/emoji_hashes" class="link">
    <h3>Emoji Hashes</h3>
    <h3>August 10th, 2017 (Revised August 13th)</h3>
    <p>
      It's definitely crossed every millenial Computer Scientist minds: How do we make a cryptographic
      function using Emojis? Well I'm here to explain exactly how by using basic cryptographic principles
      to create a custom emoji hash.
    </p>
  </a>

  <a href="/bits_bytes_bitwise" class="link">
    <h3>Bits, Bytes and Bitwise Operations</h3>
    <h3>August 9th, 2017</h3>
    <p>
      Ever wondered what it's like to write bitwise operators from scratch? Well, I'm going to be writing
      all the bitwise operators from scratch in Node.js abstractions.
    </p>
  </a>

  <h2>Q&amp;A with Chris Cates</h2>
  <h3>1. What's your favourite language?</h3>
  <p>
    It used to be Kotlin. But now it's Rust by a long shot. Rust lends itself to a functional paradigm
    while also being a systems programming language. It's extremely expressive and I feel complete
    fidelity and control over the flow and results the language provides. It's like C++ but way
    better and more fun to code in.
  </p>

  <h3>2. What are your thoughts on the Brainfuck language?</h3>
  <p>
    More inexperienced developers generally have a negative opinion about Brainfuck... However Brainfuck
    is not really a "Brain fuck" to me... It's actually an enjoyable development experience despite not being
    DRY. Overall, I think it lends itself as a great teaching tool about fundamental computer science concepts
    so don't dismiss it! However as a work tool... It's definitely not useful... Might make more sense to write
    core endian and syntax structures in binary instead if you want to go that route.
  </p>

  <h3>3. What are you working on these days?</h3>
  <p>
    I've been working on a lot of math based problems.
    For example I have section of my website dedicated to every proposition Euclid made in The Books of Euclid.
    I will also in the future have sections dedicated to Archimedes "The Method" and perhaps even some stuff
    on advanced trascendentals in Calculus and pure mathematics.
  </p>

</div>
